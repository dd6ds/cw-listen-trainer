use std::{fs, path::Path, path::PathBuf, time::Duration};
use std::collections::HashSet;
use rand::prelude::IndexedRandom;
use bevy::prelude::*;

#[derive(Component)]
struct CurrentFileText;

#[derive(Component)]
struct ScoreText;

#[derive(Component)]
struct CurrentAudioPlayer;

#[derive(Component)]
struct PlayPauseButton;

#[derive(Component)]
struct StopButton;

#[derive(Component)]
struct StartButton;

#[derive(Component)]
struct AnswerInput;

#[derive(Component)]
struct SubmitButton;

#[derive(Component)]
struct ModeSelectionUI;

#[derive(Component)]
struct TrainAllButton;

#[derive(Component)]
struct TrainCustomButton;

#[derive(Component)]
struct CharacterCheckbox {
    character: String,
}

#[derive(Component)]
struct CharacterSelectionUI;

#[derive(Component)]
struct StartTrainingButton;

#[derive(Component)]
struct BackButton;

#[derive(Component)]
struct SelectAllButton;

#[derive(Component)]
struct ClearAllButton;

#[derive(Component)]
struct CharacterGrid;

#[derive(Resource)]
struct AudioState {
    state: PlayState,
    pause_timer: Timer,
    play_start_timer: Timer,
    user_paused: bool,
    current_file: Option<String>,
    current_file_path: Option<PathBuf>,
    user_answer: String,
    correct_count: u32,
    wrong_count: u32,
    was_correct: bool,
    repeat_count: u32,
    repeat_pause_timer: Timer,
    training_mode: TrainingMode,
    selected_characters: HashSet<String>,
    available_characters: Vec<String>,
}

#[derive(PartialEq, Clone)]
enum PlayState {
    ModeSelection,
    CharacterSelection,
    Playing,
    Pausing,
    WaitingForAnswer,
    ReadyToPlay,
    Stopped,
    RepeatPlaying,
    RepeatPausing,
}

#[derive(PartialEq, Clone)]
enum TrainingMode {
    All,
    Custom,
    NotSelected,
}

impl Default for AudioState {
    fn default() -> Self {
        Self {
            state: PlayState::ModeSelection,
            pause_timer: Timer::new(Duration::from_secs(2), TimerMode::Once),
            play_start_timer: Timer::new(Duration::from_millis(500), TimerMode::Once),
            user_paused: false,
            current_file: None,
            current_file_path: None,
            user_answer: String::new(),
            correct_count: 0,
            wrong_count: 0,
            was_correct: true,
            repeat_count: 0,
            repeat_pause_timer: Timer::new(Duration::from_millis(800), TimerMode::Once),
            training_mode: TrainingMode::NotSelected,
            selected_characters: HashSet::new(),
            available_characters: Vec::new(),
        }
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "CW Listen Trainer - Enhanced".to_string(),
                resolution: (900.0, 600.0).into(),
                ..default()
            }),
            ..default()
        }))
        .init_resource::<AudioState>()
        .add_systems(Startup, (setup_ui, scan_available_characters))
        .add_systems(Update, (
            audio_player_system, 
            button_system, 
            text_input_system, 
            keyboard_input_system, 
            update_score_display,
            mode_selection_system,
            character_selection_system,
            checkbox_system,
            create_character_checkboxes,
        ))
        .run();
}

fn scan_available_characters(mut audio_state: ResMut<AudioState>) {
    let soundpath = "assets/sounds";
    let path = Path::new(soundpath);
    
    if !path.exists() {
        eprintln!("Fehler: Verzeichnis nicht gefunden: {}", soundpath);
        return;
    }
    
    let mut characters = HashSet::new();
    
    if let Ok(entries) = fs::read_dir(soundpath) {
        for entry in entries.filter_map(|e| e.ok()) {
            if let Some(ext) = entry.path().extension() {
                if ext == "mp3" || ext == "ogg" || ext == "wav" {
                    if let Some(stem) = entry.path().file_stem() {
                        if let Some(name) = stem.to_str() {
                            characters.insert(name.to_string());
                        }
                    }
                }
            }
        }
    }
    
    audio_state.available_characters = characters.into_iter().collect();
    audio_state.available_characters.sort();
}

fn setup_ui(mut commands: Commands) {
    commands.spawn(Camera2d);
    
    // Mode Selection UI
    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            flex_direction: FlexDirection::Column,
            ..default()
        },
        BackgroundColor(Color::srgb(0.1, 0.1, 0.1)),
        ModeSelectionUI,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new("CW Listen Trainer"),
            TextFont {
                font_size: 48.0,
                ..default()
            },
            TextColor(Color::WHITE),
            Node {
                margin: UiRect::bottom(Val::Px(50.0)),
                ..default()
            },
        ));
        
        parent.spawn((
            Text::new("Wähle Trainingsmodus:"),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::srgb(0.8, 0.8, 0.8)),
            Node {
                margin: UiRect::bottom(Val::Px(30.0)),
                ..default()
            },
        ));
        
        parent.spawn((
            Button,
            Node {
                width: Val::Px(250.0),
                height: Val::Px(60.0),
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                margin: UiRect::all(Val::Px(10.0)),
                ..default()
            },
            BackgroundColor(Color::srgb(0.2, 0.5, 0.8)),
            TrainAllButton,
        ))
        .with_children(|parent| {
            parent.spawn((
                Text::new("Alle Zeichen trainieren"),
                TextFont {
                    font_size: 20.0,
                    ..default()
                },
                TextColor(Color::WHITE),
            ));
        });
        
        parent.spawn((
            Button,
            Node {
                width: Val::Px(250.0),
                height: Val::Px(60.0),
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                margin: UiRect::all(Val::Px(10.0)),
                ..default()
            },
            BackgroundColor(Color::srgb(0.2, 0.6, 0.2)),
            TrainCustomButton,
        ))
        .with_children(|parent| {
            parent.spawn((
                Text::new("Zeichen auswählen"),
                TextFont {
                    font_size: 20.0,
                    ..default()
                },
                TextColor(Color::WHITE),
            ));
        });
    });
    
    // Character Selection UI (initially hidden)
    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            justify_content: JustifyContent::Start,
            align_items: AlignItems::Center,
            flex_direction: FlexDirection::Column,
            padding: UiRect::all(Val::Px(20.0)),
            ..default()
        },
        BackgroundColor(Color::srgb(0.1, 0.1, 0.1)),
        Visibility::Hidden,
        CharacterSelectionUI,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new("Wähle Zeichen zum Trainieren:"),
            TextFont {
                font_size: 28.0,
                ..default()
            },
            TextColor(Color::WHITE),
            Node {
                margin: UiRect::bottom(Val::Px(20.0)),
                ..default()
            },
        ));
        
        // Button row
        parent.spawn(Node {
            flex_direction: FlexDirection::Row,
            margin: UiRect::bottom(Val::Px(20.0)),
            ..default()
        })
        .with_children(|parent| {
            parent.spawn((
                Button,
                Node {
                    width: Val::Px(120.0),
                    height: Val::Px(40.0),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    margin: UiRect::horizontal(Val::Px(5.0)),
                    ..default()
                },
                BackgroundColor(Color::srgb(0.3, 0.5, 0.3)),
                SelectAllButton,
            ))
            .with_children(|parent| {
                parent.spawn((
                    Text::new("Alle wählen"),
                    TextFont {
                        font_size: 16.0,
                        ..default()
                    },
                    TextColor(Color::WHITE),
                ));
            });
            
            parent.spawn((
                Button,
                Node {
                    width: Val::Px(120.0),
                    height: Val::Px(40.0),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    margin: UiRect::horizontal(Val::Px(5.0)),
                    ..default()
                },
                BackgroundColor(Color::srgb(0.5, 0.3, 0.3)),
                ClearAllButton,
            ))
            .with_children(|parent| {
                parent.spawn((
                    Text::new("Alle abwählen"),
                    TextFont {
                        font_size: 16.0,
                        ..default()
                    },
                    TextColor(Color::WHITE),
                ));
            });
        });
        
        // Scrollable character grid container
        parent.spawn((
            Node {
                width: Val::Px(800.0),
                height: Val::Px(350.0),
                flex_direction: FlexDirection::Column,
                overflow: Overflow::clip_y(),
                ..default()
            },
            BackgroundColor(Color::srgb(0.15, 0.15, 0.15)),
        ))
        .with_children(|parent| {
            // Character grid will be populated dynamically
            parent.spawn((
                Node {
                    flex_direction: FlexDirection::Row,
                    flex_wrap: FlexWrap::Wrap,
                    justify_content: JustifyContent::Start,
                    padding: UiRect::all(Val::Px(10.0)),
                    ..default()
                },
                CharacterGrid,
            ));
        });
        
        // Bottom buttons
        parent.spawn(Node {
            flex_direction: FlexDirection::Row,
            margin: UiRect::top(Val::Px(20.0)),
            ..default()
        })
        .with_children(|parent| {
            parent.spawn((
                Button,
                Node {
                    width: Val::Px(150.0),
                    height: Val::Px(50.0),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    margin: UiRect::horizontal(Val::Px(10.0)),
                    ..default()
                },
                BackgroundColor(Color::srgb(0.5, 0.5, 0.5)),
                BackButton,
            ))
            .with_children(|parent| {
                parent.spawn((
                    Text::new("Zurück"),
                    TextFont {
                        font_size: 20.0,
                        ..default()
                    },
                    TextColor(Color::WHITE),
                ));
            });
            
            parent.spawn((
                Button,
                Node {
                    width: Val::Px(150.0),
                    height: Val::Px(50.0),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    margin: UiRect::horizontal(Val::Px(10.0)),
                    ..default()
                },
                BackgroundColor(Color::srgb(0.2, 0.6, 0.2)),
                StartTrainingButton,
            ))
            .with_children(|parent| {
                parent.spawn((
                    Text::new("Training starten"),
                    TextFont {
                        font_size: 20.0,
                        ..default()
                    },
                    TextColor(Color::WHITE),
                ));
            });
        });
    });
    
    // Main training UI (initially hidden)
    commands.spawn((
        Text::new("Bereit..."),
        TextFont {
            font_size: 24.0,
            ..default()
        },
        TextColor(Color::WHITE),
        TextLayout::new_with_justify(JustifyText::Left),
        Node {
            position_type: PositionType::Absolute,
            left: Val::Px(50.0),
            right: Val::Px(50.0),
            top: Val::Px(20.0),
            height: Val::Px(100.0),
            justify_content: JustifyContent::Start,
            align_items: AlignItems::Start,
            ..default()
        },
        Visibility::Hidden,
        CurrentFileText,
    ));
    
    // Score display
    commands.spawn((
        Text::new("Richtig: 0 | Falsch: 0"),
        TextFont {
            font_size: 20.0,
            ..default()
        },
        TextColor(Color::srgb(0.8, 0.8, 0.8)),
        TextLayout::new_with_justify(JustifyText::Right),
        Node {
            position_type: PositionType::Absolute,
            right: Val::Px(50.0),
            top: Val::Px(20.0),
            ..default()
        },
        Visibility::Hidden,
        ScoreText,
    ));
    
    // Answer input
    commands.spawn((
        Node {
            width: Val::Px(300.0),
            height: Val::Px(50.0),
            position_type: PositionType::Absolute,
            left: Val::Px(250.0),
            top: Val::Px(140.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            border: UiRect::all(Val::Px(2.0)),
            ..default()
        },
        BackgroundColor(Color::srgb(0.15, 0.15, 0.15)),
        BorderColor(Color::srgb(0.5, 0.5, 0.5)),
        Visibility::Hidden,
        AnswerInput,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new(""),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::WHITE),
        ));
    });
    
    // Submit button
    commands.spawn((
        Button,
        Node {
            width: Val::Px(150.0),
            height: Val::Px(50.0),
            position_type: PositionType::Absolute,
            left: Val::Px(325.0),
            top: Val::Px(210.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgb(0.3, 0.7, 0.3)),
        Visibility::Hidden,
        SubmitButton,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new("Bestätigen"),
            TextFont {
                font_size: 20.0,
                ..default()
            },
            TextColor(Color::WHITE),
        ));
    });
    
    // Control buttons
    commands.spawn((
        Button,
        Node {
            width: Val::Px(150.0),
            height: Val::Px(50.0),
            position_type: PositionType::Absolute,
            left: Val::Px(80.0),
            bottom: Val::Px(30.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgb(0.2, 0.5, 0.8)),
        Visibility::Hidden,
        StartButton,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new("Start"),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::WHITE),
        ));
    });
    
    commands.spawn((
        Button,
        Node {
            width: Val::Px(150.0),
            height: Val::Px(50.0),
            position_type: PositionType::Absolute,
            left: Val::Px(250.0),
            bottom: Val::Px(30.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgb(0.2, 0.6, 0.2)),
        Visibility::Hidden,
        PlayPauseButton,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new("Pause"),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::WHITE),
        ));
    });
    
    commands.spawn((
        Button,
        Node {
            width: Val::Px(150.0),
            height: Val::Px(50.0),
            position_type: PositionType::Absolute,
            left: Val::Px(420.0),
            bottom: Val::Px(30.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgb(0.8, 0.2, 0.2)),
        Visibility::Hidden,
        StopButton,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new("Stopp"),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::WHITE),
        ));
    });
}

fn mode_selection_system(
    mut interaction_query: Query<
        (&Interaction, Option<&TrainAllButton>, Option<&TrainCustomButton>),
        Changed<Interaction>,
    >,
    mut audio_state: ResMut<AudioState>,
    mut mode_ui_query: Query<&mut Visibility, (With<ModeSelectionUI>, Without<CharacterSelectionUI>)>,
    mut char_ui_query: Query<&mut Visibility, (With<CharacterSelectionUI>, Without<ModeSelectionUI>)>,
    _char_grid_query: Query<Entity, With<Node>>,
    mut training_ui_query: Query<&mut Visibility, Or<(
        With<CurrentFileText>,
        With<ScoreText>,
        With<StartButton>,
        With<PlayPauseButton>,
        With<StopButton>,
    )>>,
) {
    for (interaction, train_all, train_custom) in &mut interaction_query {
        if *interaction == Interaction::Pressed {
            if train_all.is_some() {
                audio_state.training_mode = TrainingMode::All;
                audio_state.selected_characters = audio_state.available_characters.iter().cloned().collect();
                audio_state.state = PlayState::ReadyToPlay;
                
                // Hide mode selection, show training UI
                for mut visibility in mode_ui_query.iter_mut() {
                    *visibility = Visibility::Hidden;
                }
                
                // Show training UI elements
                for mut visibility in training_ui_query.iter_mut() {
                    *visibility = Visibility::Visible;
                }
            } else if train_custom.is_some() {
                audio_state.training_mode = TrainingMode::Custom;
                
                // Hide mode selection, show character selection
                for mut visibility in mode_ui_query.iter_mut() {
                    *visibility = Visibility::Hidden;
                }
                for mut visibility in char_ui_query.iter_mut() {
                    *visibility = Visibility::Visible;
                }
                
                // Populate character checkboxes
                populate_character_checkboxes(&mut audio_state);
            }
        }
    }
}

fn populate_character_checkboxes(audio_state: &mut ResMut<AudioState>) {
    // Store the available characters for later use in creating the checkboxes
    // The actual checkbox creation will happen in a separate system
    audio_state.selected_characters.clear();
}

fn create_character_checkboxes(
    mut commands: Commands,
    audio_state: Res<AudioState>,
    char_grid_query: Query<(Entity, &Children), With<CharacterGrid>>,
    existing_checkboxes: Query<Entity, With<CharacterCheckbox>>,
) {
    // Only create checkboxes if we're in custom mode and they don't exist yet
    if audio_state.training_mode != TrainingMode::Custom {
        return;
    }
    
    // Check if checkboxes already exist
    if !existing_checkboxes.is_empty() {
        return;
    }
    
    // Find the grid container
    if let Ok((grid_entity, _)) = char_grid_query.single() {
        // Create checkboxes for each available character
        for character in &audio_state.available_characters {
            let checkbox = commands.spawn((
                Button,
                Node {
                    width: Val::Px(80.0),
                    height: Val::Px(40.0),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    margin: UiRect::all(Val::Px(5.0)),
                    ..default()
                },
                BackgroundColor(Color::srgb(0.3, 0.3, 0.3)),
                CharacterCheckbox {
                    character: character.clone(),
                },
            ))
            .with_children(|parent| {
                parent.spawn((
                    Text::new(character.clone()),
                    TextFont {
                        font_size: 18.0,
                        ..default()
                    },
                    TextColor(Color::WHITE),
                ));
            })
            .id();
            
            commands.entity(grid_entity).add_children(&[checkbox]);
        }
    }
}

fn checkbox_system(
    mut interaction_query: Query<
        (&Interaction, &mut BackgroundColor, &CharacterCheckbox),
        Changed<Interaction>,
    >,
    mut audio_state: ResMut<AudioState>,
) {
    for (interaction, mut color, checkbox) in &mut interaction_query {
        if *interaction == Interaction::Pressed {
            if audio_state.selected_characters.contains(&checkbox.character) {
                audio_state.selected_characters.remove(&checkbox.character);
                *color = Color::srgb(0.3, 0.3, 0.3).into();
            } else {
                audio_state.selected_characters.insert(checkbox.character.clone());
                *color = Color::srgb(0.2, 0.6, 0.2).into();
            }
        }
    }
}

fn character_selection_system(
    mut commands: Commands,
    mut interaction_query: Query<
        (&Interaction, Option<&StartTrainingButton>, Option<&BackButton>, Option<&SelectAllButton>, Option<&ClearAllButton>),
        Changed<Interaction>,
    >,
    mut audio_state: ResMut<AudioState>,
    mut mode_ui_query: Query<&mut Visibility, (With<ModeSelectionUI>, Without<CharacterSelectionUI>)>,
    mut char_ui_query: Query<&mut Visibility, (With<CharacterSelectionUI>, Without<ModeSelectionUI>)>,
    mut checkbox_query: Query<(Entity, &mut BackgroundColor, &CharacterCheckbox)>,
    mut training_ui_query: Query<&mut Visibility, Or<(
        With<CurrentFileText>,
        With<ScoreText>,
        With<StartButton>,
        With<PlayPauseButton>,
        With<StopButton>,
    )>>,
) {
    for (interaction, start_training, back, select_all, clear_all) in &mut interaction_query {
        if *interaction == Interaction::Pressed {
            if start_training.is_some() && !audio_state.selected_characters.is_empty() {
                audio_state.state = PlayState::ReadyToPlay;
                
                // Hide character selection, show training UI
                for mut visibility in char_ui_query.iter_mut() {
                    *visibility = Visibility::Hidden;
                }
                
                // Show training UI elements
                for mut visibility in training_ui_query.iter_mut() {
                    *visibility = Visibility::Visible;
                }
            } else if back.is_some() {
                // Go back to mode selection
                audio_state.selected_characters.clear();
                audio_state.training_mode = TrainingMode::NotSelected;
                audio_state.state = PlayState::ModeSelection;
                
                // Clean up checkboxes
                for (entity, _, _) in checkbox_query.iter() {
                    commands.entity(entity).despawn_recursive();
                }
                
                for mut visibility in char_ui_query.iter_mut() {
                    *visibility = Visibility::Hidden;
                }
                for mut visibility in mode_ui_query.iter_mut() {
                    *visibility = Visibility::Visible;
                }
            } else if select_all.is_some() {
                // Select all characters
                audio_state.selected_characters = audio_state.available_characters.iter().cloned().collect();
                for (_, mut color, _) in checkbox_query.iter_mut() {
                    *color = Color::srgb(0.2, 0.6, 0.2).into();
                }
            } else if clear_all.is_some() {
                // Clear all selections
                audio_state.selected_characters.clear();
                for (_, mut color, _) in checkbox_query.iter_mut() {
                    *color = Color::srgb(0.3, 0.3, 0.3).into();
                }
            }
        }
    }
}

fn button_system(
    mut interaction_query: Query<
        (&Interaction, &mut BackgroundColor, Option<&PlayPauseButton>, Option<&StopButton>, Option<&StartButton>, Option<&SubmitButton>),
        Changed<Interaction>,
    >,
    mut audio_state: ResMut<AudioState>,
    audio_query: Query<&AudioSink, With<CurrentAudioPlayer>>,
    button_query: Query<&Children, With<PlayPauseButton>>,
    mut status_text_query: Query<&mut Text, With<CurrentFileText>>,
    mut button_text_query: Query<&mut Text, Without<CurrentFileText>>,
) {
    for (interaction, mut color, play_pause, stop, start, submit) in &mut interaction_query {
        match *interaction {
            Interaction::Pressed => {
                if start.is_some() {
                    if audio_state.state == PlayState::Stopped {
                        audio_state.state = PlayState::ReadyToPlay;
                        audio_state.user_paused = false;
                    }
                } else if submit.is_some() {
                    if audio_state.state == PlayState::WaitingForAnswer && !audio_state.user_answer.is_empty() {
                        check_answer_submit(&mut audio_state, &mut status_text_query);
                    }
                } else if play_pause.is_some() {
                    audio_state.user_paused = !audio_state.user_paused;
                    
                    for sink in audio_query.iter() {
                        if audio_state.user_paused {
                            sink.pause();
                        } else {
                            sink.play();
                        }
                    }
                    
                    if let Ok(children) = button_query.single() {
                        for child in children.iter() {
                            if let Ok(mut text) = button_text_query.get_mut(child) {
                                **text = if audio_state.user_paused {
                                    "Weiter".to_string()
                                } else {
                                    "Pause".to_string()
                                };
                            }
                        }
                    }
                } else if stop.is_some() {
                    audio_state.state = PlayState::Stopped;
                    audio_state.user_paused = false;
                }
            }
            Interaction::Hovered => {
                *color = if submit.is_some() {
                    Color::srgb(0.35, 0.8, 0.35).into()
                } else if play_pause.is_some() {
                    Color::srgb(0.25, 0.7, 0.25).into()
                } else if stop.is_some() {
                    Color::srgb(0.9, 0.3, 0.3).into()
                } else {
                    Color::srgb(0.3, 0.6, 0.9).into()
                };
            }
            Interaction::None => {
                *color = if submit.is_some() {
                    Color::srgb(0.3, 0.7, 0.3).into()
                } else if play_pause.is_some() {
                    Color::srgb(0.2, 0.6, 0.2).into()
                } else if stop.is_some() {
                    Color::srgb(0.8, 0.2, 0.2).into()
                } else {
                    Color::srgb(0.2, 0.5, 0.8).into()
                };
            }
        }
    }
}

fn check_answer_submit(
    audio_state: &mut ResMut<AudioState>,
    text_query: &mut Query<&mut Text, With<CurrentFileText>>,
) {
    if let Some(correct_answer) = &audio_state.current_file {
        let correct_answer = correct_answer.clone();
        let user_answer = audio_state.user_answer.trim().to_lowercase();
        let correct = correct_answer.to_lowercase();
        
        let is_correct = user_answer == correct;
        
        if is_correct {
            audio_state.correct_count += 1;
            audio_state.was_correct = true;
            
            for mut text in text_query.iter_mut() {
                **text = format!("{}", correct_answer);
            }
            
            audio_state.user_answer.clear();
            audio_state.pause_timer = Timer::new(Duration::from_secs(2), TimerMode::Once);
            audio_state.pause_timer.reset();
            audio_state.state = PlayState::Pausing;
        } else {
            audio_state.wrong_count += 1;
            audio_state.was_correct = false;
            
            for mut text in text_query.iter_mut() {
                **text = format!("Erwartet: {}\nDeine Antwort: {}\n\nWiederhole 3x...", 
                    correct_answer, audio_state.user_answer);
            }
            
            audio_state.user_answer.clear();
            audio_state.repeat_count = 0;
            audio_state.repeat_pause_timer.reset();
            audio_state.state = PlayState::RepeatPausing;
        }
        
        println!("Antwort: {} | Richtig: {} | Korrekt: {}", user_answer, correct, is_correct);
    }
}

fn keyboard_input_system(
    keys: Res<ButtonInput<KeyCode>>,
    mut audio_state: ResMut<AudioState>,
    input_query: Query<&Children, With<AnswerInput>>,
    mut status_text_query: Query<&mut Text, With<CurrentFileText>>,
    mut all_text_query: Query<&mut Text, Without<CurrentFileText>>,
) {
    if audio_state.state != PlayState::WaitingForAnswer {
        return;
    }
    
    if keys.just_pressed(KeyCode::Backspace) {
        audio_state.user_answer.pop();
        update_input_text(&input_query, &mut all_text_query, &audio_state.user_answer);
    }
    
    if keys.just_pressed(KeyCode::Enter) && !audio_state.user_answer.is_empty() {
        check_answer(&mut audio_state, &mut status_text_query);
        return;
    }
    
    let shift = keys.pressed(KeyCode::ShiftLeft) || keys.pressed(KeyCode::ShiftRight);
    
    let character = if keys.just_pressed(KeyCode::KeyA) { Some('a') }
    else if keys.just_pressed(KeyCode::KeyB) { Some('b') }
    else if keys.just_pressed(KeyCode::KeyC) { Some('c') }
    else if keys.just_pressed(KeyCode::KeyD) { Some('d') }
    else if keys.just_pressed(KeyCode::KeyE) { Some('e') }
    else if keys.just_pressed(KeyCode::KeyF) { Some('f') }
    else if keys.just_pressed(KeyCode::KeyG) { Some('g') }
    else if keys.just_pressed(KeyCode::KeyH) { Some('h') }
    else if keys.just_pressed(KeyCode::KeyI) { Some('i') }
    else if keys.just_pressed(KeyCode::KeyJ) { Some('j') }
    else if keys.just_pressed(KeyCode::KeyK) { Some('k') }
    else if keys.just_pressed(KeyCode::KeyL) { Some('l') }
    else if keys.just_pressed(KeyCode::KeyM) { Some('m') }
    else if keys.just_pressed(KeyCode::KeyN) { Some('n') }
    else if keys.just_pressed(KeyCode::KeyO) { Some('o') }
    else if keys.just_pressed(KeyCode::KeyP) { Some('p') }
    else if keys.just_pressed(KeyCode::KeyQ) { Some('q') }
    else if keys.just_pressed(KeyCode::KeyR) { Some('r') }
    else if keys.just_pressed(KeyCode::KeyS) { Some('s') }
    else if keys.just_pressed(KeyCode::KeyT) { Some('t') }
    else if keys.just_pressed(KeyCode::KeyU) { Some('u') }
    else if keys.just_pressed(KeyCode::KeyV) { Some('v') }
    else if keys.just_pressed(KeyCode::KeyW) { Some('w') }
    else if keys.just_pressed(KeyCode::KeyX) { Some('x') }
    else if keys.just_pressed(KeyCode::KeyY) { Some('y') }
    else if keys.just_pressed(KeyCode::KeyZ) { Some('z') }
    else if keys.just_pressed(KeyCode::Digit0) { Some('0') }
    else if keys.just_pressed(KeyCode::Digit1) { Some('1') }
    else if keys.just_pressed(KeyCode::Digit2) { Some('2') }
    else if keys.just_pressed(KeyCode::Digit3) { Some('3') }
    else if keys.just_pressed(KeyCode::Digit4) { Some('4') }
    else if keys.just_pressed(KeyCode::Digit5) { Some('5') }
    else if keys.just_pressed(KeyCode::Digit6) { Some('6') }
    else if keys.just_pressed(KeyCode::Digit7) { Some('7') }
    else if keys.just_pressed(KeyCode::Digit8) { Some('8') }
    else if keys.just_pressed(KeyCode::Digit9) { Some('9') }
    else if keys.just_pressed(KeyCode::Minus) { Some('-') }
    else if keys.just_pressed(KeyCode::Space) { Some(' ') }
    else if keys.just_pressed(KeyCode::Semicolon) { Some('ö') }
    else if keys.just_pressed(KeyCode::Quote) { Some('ä') }
    else if keys.just_pressed(KeyCode::BracketLeft) { Some('ü') }
    else { None };
    
    if let Some(ch) = character {
        let final_char = if shift && ch.is_alphabetic() {
            ch.to_uppercase().next().unwrap()
        } else {
            ch
        };
        
        audio_state.user_answer.push(final_char);
        update_input_text(&input_query, &mut all_text_query, &audio_state.user_answer);
    }
}

fn check_answer(
    audio_state: &mut ResMut<AudioState>,
    text_query: &mut Query<&mut Text, With<CurrentFileText>>,
) {
    if let Some(correct_answer) = &audio_state.current_file {
        let correct_answer = correct_answer.clone();
        let user_answer = audio_state.user_answer.trim().to_lowercase();
        let correct = correct_answer.to_lowercase();
        
        let is_correct = user_answer == correct;
        
        if is_correct {
            audio_state.correct_count += 1;
            audio_state.was_correct = true;
            
            for mut text in text_query.iter_mut() {
                **text = format!("{}", correct_answer);
            }
            
            audio_state.user_answer.clear();
            audio_state.pause_timer = Timer::new(Duration::from_secs(2), TimerMode::Once);
            audio_state.pause_timer.reset();
            audio_state.state = PlayState::Pausing;
        } else {
            audio_state.wrong_count += 1;
            audio_state.was_correct = false;
            
            for mut text in text_query.iter_mut() {
                **text = format!("Erwartet: {}\nDeine Antwort: {}\n\nWiederhole 3x...", 
                    correct_answer, audio_state.user_answer);
            }
            
            audio_state.user_answer.clear();
            audio_state.repeat_count = 0;
            audio_state.repeat_pause_timer.reset();
            audio_state.state = PlayState::RepeatPausing;
        }
        
        println!("Antwort: {} | Richtig: {} | Korrekt: {}", user_answer, correct, is_correct);
    }
}

fn update_input_text(
    input_query: &Query<&Children, With<AnswerInput>>,
    text_query: &mut Query<&mut Text, Without<CurrentFileText>>,
    answer: &str,
) {
    if let Ok(children) = input_query.single() {
        for child in children.iter() {
            if let Ok(mut text) = text_query.get_mut(child) {
                **text = answer.to_string();
            }
        }
    }
}

fn text_input_system(
    mut input_query: Query<&mut Visibility, With<AnswerInput>>,
    mut submit_query: Query<&mut Visibility, (With<SubmitButton>, Without<AnswerInput>)>,
    audio_state: Res<AudioState>,
) {
    let should_show = audio_state.state == PlayState::WaitingForAnswer;
    
    for mut visibility in input_query.iter_mut() {
        *visibility = if should_show {
            Visibility::Visible
        } else {
            Visibility::Hidden
        };
    }
    
    for mut visibility in submit_query.iter_mut() {
        *visibility = if should_show {
            Visibility::Visible
        } else {
            Visibility::Hidden
        };
    }
}

fn update_score_display(
    audio_state: Res<AudioState>,
    mut score_query: Query<&mut Text, With<ScoreText>>,
) {
    if audio_state.is_changed() {
        for mut text in score_query.iter_mut() {
            **text = format!("Richtig: {} | Falsch: {}", 
                audio_state.correct_count, audio_state.wrong_count);
        }
    }
}

fn get_sound_file(audio_state: &AudioState) -> Option<(PathBuf, String)> {
    let soundpath = "assets/sounds";
    let path = Path::new(soundpath);
    
    if !path.exists() {
        eprintln!("Fehler: Verzeichnis nicht gefunden: {}", soundpath);
        return None;
    }
    
    let selected_chars = &audio_state.selected_characters;
    if selected_chars.is_empty() {
        return None;
    }
    
    let audio_files: Vec<_> = fs::read_dir(soundpath)
        .expect("Kann Verzeichnis nicht lesen")
        .filter_map(|entry| entry.ok())
        .filter(|entry| {
            if let Some(stem) = entry.path().file_stem() {
                if let Some(name) = stem.to_str() {
                    if selected_chars.contains(name) {
                        if let Some(ext) = entry.path().extension() {
                            return ext == "mp3" || ext == "ogg" || ext == "wav";
                        }
                    }
                }
            }
            false
        })
        .collect();
    
    if audio_files.is_empty() {
        eprintln!("Fehler: Keine passenden Audio-Dateien gefunden!");
        return None;
    }
    
    let mut rng = rand::rng();
    let random_file = audio_files.choose(&mut rng)?;
    let full_path = random_file.path();
    
    let filename_without_ext = full_path
        .file_stem()
        .and_then(|n| n.to_str())
        .unwrap_or("Unbekannt")
        .to_string();
    
    let asset_path = full_path.strip_prefix("assets/").ok()?.to_owned();
    
    Some((asset_path, filename_without_ext))
}

fn audio_player_system(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut text_query: Query<&mut Text, With<CurrentFileText>>,
    audio_query: Query<(Entity, &AudioSink), With<CurrentAudioPlayer>>,
    mut audio_state: ResMut<AudioState>,
    time: Res<Time>,
) {
    if audio_state.state == PlayState::Stopped || audio_state.state == PlayState::ModeSelection || audio_state.state == PlayState::CharacterSelection {
        for (entity, _) in audio_query.iter() {
            commands.entity(entity).despawn();
        }
        
        if audio_state.state == PlayState::Stopped {
            for mut text in text_query.iter_mut() {
                **text = "Gestoppt".to_string();
            }
        }
        return;
    }
    
    if audio_state.user_paused {
        return;
    }
    
    match audio_state.state {
        PlayState::ReadyToPlay => {
            for (entity, _) in audio_query.iter() {
                commands.entity(entity).despawn();
            }
            
            if let Some((randsoundfile, filename_without_ext)) = get_sound_file(&audio_state) {
                let audio_handle = asset_server.load(&*randsoundfile);
                commands.spawn((
                    AudioPlayer::new(audio_handle),
                    CurrentAudioPlayer,
                ));
                
                println!("Spiele: {} (Antwort: {})", randsoundfile.display(), filename_without_ext);
                
                for mut text in text_query.iter_mut() {
                    **text = "Höre zu...".to_string();
                }
                
                audio_state.current_file = Some(filename_without_ext);
                audio_state.current_file_path = Some(randsoundfile);
                audio_state.play_start_timer.reset();
                audio_state.state = PlayState::Playing;
            } else {
                for mut text in text_query.iter_mut() {
                    **text = "Keine Zeichen ausgewählt!".to_string();
                }
                audio_state.state = PlayState::Stopped;
            }
        }
        PlayState::Playing => {
            audio_state.play_start_timer.tick(time.delta());
            
            if !audio_state.play_start_timer.finished() {
                return;
            }
            
            let is_playing = audio_query.iter().any(|(_, sink)| !sink.empty());
            
            if !is_playing {
                for (entity, _) in audio_query.iter() {
                    commands.entity(entity).despawn();
                }
                
                println!("Sound fertig, warte auf Antwort...");
                audio_state.state = PlayState::WaitingForAnswer;
                audio_state.user_answer.clear();
                
                for mut text in text_query.iter_mut() {
                    **text = "Welches Zeichen?".to_string();
                }
            }
        }
        PlayState::WaitingForAnswer => {
        }
        PlayState::Pausing => {
            audio_state.pause_timer.tick(time.delta());
            
            if audio_state.pause_timer.fraction() < 0.3 {
            } else {
                for mut text in text_query.iter_mut() {
                    **text = "Pause...".to_string();
                }
            }
            
            if audio_state.pause_timer.finished() {
                println!("Pause vorbei, spiele nächsten Sound...");
                audio_state.state = PlayState::ReadyToPlay;
            }
        }
        PlayState::RepeatPausing => {
            audio_state.repeat_pause_timer.tick(time.delta());
            
            if audio_state.repeat_pause_timer.finished() {
                if audio_state.repeat_count < 3 {
                    for (entity, _) in audio_query.iter() {
                        commands.entity(entity).despawn();
                    }
                    
                    if let Some(file_path) = &audio_state.current_file_path {
                        let audio_handle = asset_server.load(&**file_path);
                        commands.spawn((
                            AudioPlayer::new(audio_handle),
                            CurrentAudioPlayer,
                        ));
                        
                        audio_state.repeat_count += 1;
                        println!("Wiederholung {}/3", audio_state.repeat_count);
                        
                        if let Some(correct_answer) = &audio_state.current_file {
                            for mut text in text_query.iter_mut() {
                                **text = format!("Lösung: {}\n\nWiederholung {}/3", 
                                    correct_answer, audio_state.repeat_count);
                            }
                        }
                        
                        audio_state.play_start_timer.reset();
                        audio_state.state = PlayState::RepeatPlaying;
                    }
                } else {
                    println!("Wiederholungen beendet, nächster Sound...");
                    audio_state.pause_timer = Timer::new(Duration::from_secs(2), TimerMode::Once);
                    audio_state.pause_timer.reset();
                    audio_state.state = PlayState::Pausing;
                }
            }
        }
        PlayState::RepeatPlaying => {
            audio_state.play_start_timer.tick(time.delta());
            
            if !audio_state.play_start_timer.finished() {
                return;
            }
            
            let is_playing = audio_query.iter().any(|(_, sink)| !sink.empty());
            
            if !is_playing {
                for (entity, _) in audio_query.iter() {
                    commands.entity(entity).despawn();
                }
                
                audio_state.repeat_pause_timer = Timer::new(Duration::from_millis(800), TimerMode::Once);
                audio_state.repeat_pause_timer.reset();
                audio_state.state = PlayState::RepeatPausing;
            }
        }
        _ => {}
    }
}
